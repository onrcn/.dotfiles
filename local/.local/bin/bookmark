#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os, sys, re, csv, json, time, shutil, sqlite3, subprocess, tempfile, fcntl
from pathlib import Path

# =========================
# Config / Constants
# =========================

BROWSER_FIREFOX_CLASSES = {
    "firefox", "zen", "zen-browser", "librewolf", "waterfox"
}
BROWSER_CHROMIUM_CLASSES = {
    "chromium", "google-chrome", "chrome", "brave", "brave-browser",
    "vivaldi", "microsoft-edge", "edge", "opera", "ungoogled-chromium", "iridium"
}
TERMINALS = ["kitty"]
DEFAULT_EDITOR = os.environ.get("EDITOR", "nvim")

CSV_DIR = Path(os.environ.get("XDG_DATA_HOME", str(Path.home() / ".local" / "share"))) / "bookmarks"
CSV_PATH = CSV_DIR / "bookmarks.csv"

URL_RE = re.compile(r'^(?:https?://|file:|ftp://|about:|chrome://|edge://|moz-extension://|view-source:).+', re.I)

# =========================
# Utils
# =========================

def run(cmd, check=False, capture=True, text=True):
    try:
        return subprocess.run(cmd, check=check, capture_output=capture, text=text)
    except Exception as e:
        return subprocess.CompletedProcess(cmd, 1, "", str(e))

def notify(msg):
    if shutil.which("notify-send"):
        subprocess.run(["notify-send", "bookmark", msg])

def ensure_csv():
    CSV_DIR.mkdir(parents=True, exist_ok=True)
    if not CSV_PATH.exists():
        with open(CSV_PATH, "w", newline="") as f:
            w = csv.writer(f, quoting=csv.QUOTE_ALL)
            w.writerow(["title", "url"])

def csv_contains_row(title, url):
    if not CSV_PATH.exists():
        return False
    with open(CSV_PATH, newline="") as f:
        r = csv.reader(f)
        next(r, None)  # skip header if present
        for row in r:
            if len(row) >= 2 and row[0] == title and row[1] == url:
                return True
    return False

def csv_append_row(title, url):
    ensure_csv()
    with open(CSV_PATH, "a+", newline="") as f:
        # lock
        fcntl.flock(f.fileno(), fcntl.LOCK_EX)
        try:
            w = csv.writer(f, quoting=csv.QUOTE_ALL)
            # dedupe full line
            if not csv_contains_row(title, url):
                w.writerow([title, url])
                f.flush()
                os.fsync(f.fileno())
                return True
            return False
        finally:
            fcntl.flock(f.fileno(), fcntl.LOCK_UN)

def get_active_window():
    """Return (app_class_lower, title) via hyprctl; None if not available."""
    if not shutil.which("hyprctl"):
        return None, None
    p = run(["hyprctl", "-j", "activewindow"])
    if p.returncode != 0 or not p.stdout.strip():
        return None, None
    try:
        j = json.loads(p.stdout)
        clazz = (j.get("class", "") or "").strip()
        title = (j.get("title", "") or "").strip()
        return clazz.lower(), title
    except Exception:
        return None, None

def is_browser_class(app_cls):
    if app_cls is None:
        return None
    if app_cls in BROWSER_FIREFOX_CLASSES:
        return "firefox"
    if app_cls in BROWSER_CHROMIUM_CLASSES:
        return "chromium"
    # allow matching prefixes like "firefox-wayland"
    for k in list(BROWSER_FIREFOX_CLASSES):
        if app_cls.startswith(k):
            return "firefox"
    for k in list(BROWSER_CHROMIUM_CLASSES):
        if app_cls.startswith(k):
            return "chromium"
    return None

# =========================
# Firefox / Zen helpers
# =========================

def decompress_jsonlz4(path: Path):
    # Firefox jsonlz4 = "mozLz40\0" + LZ4_BLOCK
    import lz4.block
    data = path.read_bytes()
    if data[:8] != b"mozLz40\0":
        raise ValueError("Not a jsonlz4 (missing magic header)")
    return json.loads(lz4.block.decompress(data[8:]))

def iter_firefox_profile_roots():
    home = Path.home()
    for root in [home / ".zen", home / ".mozilla" / "firefox", home / ".librewolf"]:
        if root.exists():
            yield root

def find_default_firefox_profile():
    for root in iter_firefox_profile_roots():
        ini = root / "profiles.ini"
        if not ini.exists():
            continue
        section = None
        default_path = None
        locked_path = None
        # crude parser
        with open(ini, "r", encoding="utf-8", errors="ignore") as f:
            lines = f.read().splitlines()
        current = {}
        for line in lines + [""]:
            if line.strip().startswith("[") and current:
                # commit
                is_default = current.get("Default", "0") == "1"
                is_locked  = current.get("Locked", "0") == "1"
                p = current.get("Path")
                if p:
                    pth = (root / p) if current.get("IsRelative", "1") == "1" else Path(p)
                    if is_locked and not locked_path:
                        locked_path = pth
                    if is_default and not default_path:
                        default_path = pth
                current = {}
            if "=" in line:
                k,v = line.split("=",1)
                current[k.strip()] = v.strip()
            elif line.strip().startswith("["):
                current = {}
        # prefer locked, else default, else most recent session dir
        candidate = locked_path or default_path
        if candidate and candidate.exists():
            return candidate
        # fallback: pick a profile that has sessionstore
        session_dirs = []
        for p in root.glob("**"):
            if p.is_dir() and (p / "sessionstore-backups").exists():
                session_dirs.append(p)
        if session_dirs:
            session_dirs.sort(key=lambda p: (p / "sessionstore-backups").stat().st_mtime, reverse=True)
            return session_dirs[0]
    return None

def read_firefox_active_tab(active_window_title: str):
    prof = find_default_firefox_profile()
    if not prof:
        raise RuntimeError("Firefox/Zen profile not found")
    backups = prof / "sessionstore-backups"
    candidates = []
    if (backups / "recovery.jsonlz4").exists():
        candidates.append(backups / "recovery.jsonlz4")
    if (prof / "sessionstore.jsonlz4").exists():
        candidates.append(prof / "sessionstore.jsonlz4")
    if not candidates:
        raise RuntimeError("No sessionstore files found")

    # retry loop to mitigate lag; also try to match the active window title
    deadline = time.time() + 3.0
    last_err = None
    while time.time() < deadline:
        for path in candidates:
            try:
                j = decompress_jsonlz4(path)
            except Exception as e:
                last_err = e
                continue

            win = choose_matching_window(j, active_window_title)
            if win is None:
                # maybe file is stale; small sleep and retry
                last_err = RuntimeError("active window not present in session yet")
                time.sleep(0.25)
                continue

            tab = extract_selected_tab(win)
            if tab:
                url, title = tab
                if URL_RE.match(url or ""):
                    return title or url, url
        time.sleep(0.25)
    raise RuntimeError(f"Could not get active tab ({last_err})")

def normalize_title(t: str):
    if not t:
        return ""
    t = t.strip()
    # remove common suffixes like " - Zen", " - Firefox"
    t = re.sub(r"\s+-\s+(Zen|Firefox|LibreWolf|Waterfox)$", "", t, flags=re.I)
    return t

def choose_matching_window(j: dict, active_title: str):
    active_title_n = normalize_title(active_title)
    wins = j.get("windows", []) or []

    # 1) exact/startswith match on window.title
    for w in wins:
        wt = normalize_title(w.get("title","") or "")
        if wt and (wt == active_title_n or active_title_n.startswith(wt) or wt.startswith(active_title_n)):
            return w

    # 2) match on selected tab's entry title
    for w in wins:
        tab = extract_selected_tab(w, only_title=True)
        if tab:
            _, t = tab
            tn = normalize_title(t)
            if tn and (tn == active_title_n or active_title_n.startswith(tn) or tn.startswith(active_title_n)):
                return w

    # 3) fall back: pick window with highest lastAccessed among selected tabs
    def last_access(w):
        t = extract_selected_tab(w, only_obj=True)
        if t:
            entries = t.get("entries") or []
            idx = (t.get("index") or len(entries)) - 1
            if 0 <= idx < len(entries):
                return entries[idx].get("lastAccessed", 0)
        return 0
    if wins:
        wins_sorted = sorted(wins, key=last_access, reverse=True)
        if wins_sorted:
            return wins_sorted[0]
    return None

def extract_selected_tab(window_obj, only_title=False, only_obj=False):
    try:
        tabs = window_obj.get("tabs") or []
        sel = (window_obj.get("selected") or 1) - 1
        if not (0 <= sel < len(tabs)):
            sel = 0
        t = tabs[sel]
        if only_obj:
            return t
        entries = t.get("entries") or []
        idx = (t.get("index") or len(entries)) - 1
        if not (0 <= idx < len(entries)) and entries:
            idx = len(entries) - 1
        if not entries:
            return None
        e = entries[idx]
        url = e.get("url") or ""
        title = e.get("title") or url
        if only_title:
            return url, title
        return url, title
    except Exception:
        return None

# =========================
# Chromium helpers
# =========================

def chromium_profile_dirs():
    home = Path.home()
    roots = [
        home / ".config" / "chromium",
        home / ".config" / "google-chrome",
        home / ".config" / "BraveSoftware" / "Brave-Browser",
        home / ".config" / "vivaldi",
        home / ".config" / "microsoft-edge",
        home / ".config" / "opera",
        home / ".config" / "ungoogled-chromium",
        home / ".config" / "iridium"
    ]
    for r in roots:
        if r.exists():
            yield r

def find_chromium_history():
    for root in chromium_profile_dirs():
        # Default first
        cand = root / "Default" / "History"
        if cand.exists():
            return cand
        # else any Profile */History
        for p in sorted(root.glob("Profile*")):
            if (p / "History").exists():
                return p / "History"
    return None

def chromium_query_latest_by_title(active_title: str):
    hist = find_chromium_history()
    if not hist:
        raise RuntimeError("Chromium history DB not found")

    # handle locked DB by copying
    tmp = None
    db_path = hist
    try:
        conn = None
        for attempt in (0,1):
            try:
                if attempt == 1:
                    # copy
                    tmp = Path(tempfile.mkdtemp()) / "History"
                    shutil.copy2(db_path, tmp)
                    path = str(tmp)
                else:
                    path = f"file:{db_path}?mode=ro"
                conn = sqlite3.connect(path, uri=(attempt==0))
                break
            except sqlite3.OperationalError:
                continue
        if conn is None:
            raise RuntimeError("Failed to open history (locked?)")

        cur = conn.cursor()
        # last_visit_time is Chrome epoch; we only need order
        cur.execute("""
            SELECT urls.title, urls.url
            FROM urls
            JOIN visits ON visits.url = urls.id
            WHERE urls.title = ?
            ORDER BY visits.visit_time DESC
            LIMIT 1
        """, (normalize_title(active_title),))
        row = cur.fetchone()
        if row:
            title, url = row
            if URL_RE.match(url or ""):
                return title or url, url

        # fallback: LIKE
        cur.execute("""
            SELECT urls.title, urls.url
            FROM urls
            JOIN visits ON visits.url = urls.id
            WHERE urls.title LIKE ?
            ORDER BY visits.visit_time DESC
            LIMIT 1
        """, (f"{normalize_title(active_title)}%",))
        row = cur.fetchone()
        if row:
            title, url = row
            if URL_RE.match(url or ""):
                return title or url, url

        raise RuntimeError("No matching URL for active window title")
    finally:
        try:
            if conn:
                conn.close()
        except Exception:
            pass
        if tmp and tmp.exists():
            shutil.rmtree(tmp, ignore_errors=True)

# =========================
# Actions
# =========================

def action_open():
    ensure_csv()
    # collect items
    items = []
    with open(CSV_PATH, newline="") as f:
        r = csv.reader(f)
        # skip header if present
        header = next(r, None)
        if header and header[:2] == ["title","url"]:
            pass
        else:
            # header is actually first row
            if header:
                items.append(header)
        for row in r:
            if len(row) >= 2:
                items.append(row[:2])

    if not items:
        notify("No bookmarks")
        print("No bookmarks.")
        return 1

    menu_items = [f"{t} - {u}" for t,u in items]

    choice = None
    if shutil.which("wofi"):
        # FIX: wofi --dmenu girdiyi stdin'den bekler; listeyi içeri pipelayalım
        p = subprocess.Popen(["wofi", "--dmenu"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, text=True)
        out, _ = p.communicate("\n".join(menu_items))
        if p.returncode == 0:
            choice = out.strip()
    elif shutil.which("dmenu"):
        p = subprocess.Popen(["dmenu"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, text=True)
        out, _ = p.communicate("\n".join(menu_items))
        if p.returncode == 0:
            choice = out.strip()
    else:
        print("wofi/dmenu not found.")
        return 1

    if not choice:
        return 1

    # parse choice
    try:
        idx = menu_items.index(choice)
    except ValueError:
        # try to split
        if " - " in choice:
            t,u = choice.split(" - ",1)
            url = u.strip()
        else:
            print("Invalid selection.")
            return 1
    else:
        t,u = items[idx]
        url = u

    # launch
    hook = Path.home() / ".local" / "bin" / "launch-browser"
    if hook.exists() and os.access(hook, os.X_OK):
        subprocess.Popen([str(hook), url], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    else:
        subprocess.Popen(["xdg-open", url], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    return 0

def action_edit():
    ensure_csv()
    term = next((t for t in TERMINALS if shutil.which(t)), None)
    if term:
        subprocess.Popen([term, "-e", DEFAULT_EDITOR, str(CSV_PATH)])
    else:
        subprocess.Popen([DEFAULT_EDITOR, str(CSV_PATH)])
    return 0

def action_grab():
    app_cls, win_title = get_active_window()
    fam = is_browser_class(app_cls)
    if fam is None:
        msg = f"Active window is not a supported browser (class={app_cls})"
        notify(msg)
        print(msg)
        return 2

    try:
        if fam == "firefox":
            title, url = read_firefox_active_tab(win_title or "")
        else:
            title, url = chromium_query_latest_by_title(win_title or "")
    except Exception as e:
        msg = f"Failed to get active tab: {e}"
        notify(msg)
        print(msg)
        return 3

    added = csv_append_row(title, url)
    if added:
        notify(f"Saved: {title}")
        print(f"Saved: {title} -> {url}")
    else:
        notify("Already saved")
        print("Already saved")
    return 0

# =========================
# Main
# =========================

def main():
    if len(sys.argv) < 2:
        print("Usage: bookmark {open|edit|grab}")
        return 1
    cmd = sys.argv[1]
    if cmd == "open":
        return action_open()
    if cmd == "edit":
        return action_edit()
    if cmd == "grab":
        return action_grab()
    print("Unknown command.")
    return 1

if __name__ == "__main__":
    sys.exit(main())

