#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os, sys, re, csv, json, time, shutil, sqlite3, subprocess, tempfile, fcntl
from pathlib import Path

# =========================
# Config / Constants
# =========================

BROWSER_FIREFOX_CLASSES = {
    "firefox", "zen", "zen-browser", "librewolf", "waterfox"
}
BROWSER_CHROMIUM_CLASSES = {
    "chromium", "google-chrome", "chrome", "brave", "brave-browser",
    "vivaldi", "microsoft-edge", "edge", "opera", "ungoogled-chromium", "iridium"
}
TERMINALS = ["kitty"]
DEFAULT_EDITOR = os.environ.get("EDITOR", "nvim")

CSV_DIR = Path(os.environ.get("XDG_DATA_HOME", str(Path.home() / ".local" / "share"))) / "bookmarks"
CSV_PATH = CSV_DIR / "bookmarks.csv"

URL_RE = re.compile(r'^(?:https?://|file:|ftp://|about:|chrome://|edge://|moz-extension://|view-source:).+', re.I)

# =========================
# Utils
# =========================

def run(cmd, check=False, capture=True, text=True):
    try:
        return subprocess.run(cmd, check=check, capture_output=capture, text=text)
    except Exception as e:
        return subprocess.CompletedProcess(cmd, 1, "", str(e))

def notify(msg):
    if shutil.which("notify-send"):
        subprocess.run(["notify-send", "bookmark", msg])

def ensure_csv():
    CSV_DIR.mkdir(parents=True, exist_ok=True)
    if not CSV_PATH.exists():
        with open(CSV_PATH, "w", newline="") as f:
            w = csv.writer(f, quoting=csv.QUOTE_ALL)
            w.writerow(["title", "url"])

def csv_contains_row(title, url):
    if not CSV_PATH.exists():
        return False
    with open(CSV_PATH, newline="") as f:
        r = csv.reader(f)
        next(r, None)  # skip header if present
        for row in r:
            if len(row) >= 2 and row[0] == title and row[1] == url:
                return True
    return False

def csv_append_row(title, url):
    ensure_csv()
    with open(CSV_PATH, "a+", newline="") as f:
        # lock
        fcntl.flock(f.fileno(), fcntl.LOCK_EX)
        try:
            w = csv.writer(f, quoting=csv.QUOTE_ALL)
            # dedupe full line
            if not csv_contains_row(title, url):
                w.writerow([title, url])
                f.flush()
                os.fsync(f.fileno())
                return True
            return False
        finally:
            fcntl.flock(f.fileno(), fcntl.LOCK_UN)

def get_active_window():
    """Return (app_class_lower, title) via hyprctl; None if not available."""
    if not shutil.which("hyprctl"):
        return None, None
    p = run(["hyprctl", "-j", "activewindow"])
    if p.returncode != 0 or not p.stdout.strip():
        return None, None
    try:
        j = json.loads(p.stdout)
        clazz = (j.get("class", "") or "").strip()
        title = (j.get("title", "") or "").strip()
        return clazz.lower(), title
    except Exception:
        return None, None

def is_browser_class(app_cls):
    if app_cls is None:
        return None
    if app_cls in BROWSER_FIREFOX_CLASSES:
        return "firefox"
    if app_cls in BROWSER_CHROMIUM_CLASSES:
        return "chromium"
    # allow matching prefixes like "firefox-wayland"
    for k in list(BROWSER_FIREFOX_CLASSES):
        if app_cls.startswith(k):
            return "firefox"
    for k in list(BROWSER_CHROMIUM_CLASSES):
        if app_cls.startswith(k):
            return "chromium"
    return None

# =========================
# Firefox / Zen helpers
# =========================

def decompress_jsonlz4(path: Path):
    # Firefox jsonlz4 = "mozLz40\0" + LZ4_BLOCK
    import lz4.block
    data = path.read_bytes()
    if data[:8] != b"mozLz40\0":
        raise ValueError("Not a jsonlz4 (missing magic header)")
    return json.loads(lz4.block.decompress(data[8:]))

def iter_firefox_profile_roots():
    home = Path.home()
    for root in [home / ".zen", home / ".mozilla" / "firefox", home / ".librewolf"]:
        if root.exists():
            yield root

def find_firefox_profiles():
    """Finds all potential profile directories."""
    profiles = []
    for root in iter_firefox_profile_roots():
        # Heuristic: a dir with prefs.js and sessionstore-backups is a profile
        for p in root.iterdir():
            if p.is_dir() and (p / "prefs.js").exists() and (p / "sessionstore-backups").exists():
                 if p not in profiles:
                    profiles.append(p)
    return profiles

def read_firefox_active_tab(active_window_title: str):
    all_windows = []
    profiles = find_firefox_profiles()

    if not profiles:
        raise RuntimeError("No Firefox/Zen profiles found")

    # In a retry loop, gather windows from all profiles' session files
    deadline = time.time() + 3.0
    last_err = None
    while time.time() < deadline:
        all_windows = []
        for prof in profiles:
            # Prioritize live session file over backup/recovery
            candidates = []
            if (prof / "sessionstore.jsonlz4").exists():
                candidates.append(prof / "sessionstore.jsonlz4")
            if (prof / "sessionstore-backups" / "recovery.jsonlz4").exists():
                candidates.append(prof / "sessionstore-backups" / "recovery.jsonlz4")

            for path in candidates:
                try:
                    j = decompress_jsonlz4(path)
                    all_windows.extend(j.get("windows", []) or [])
                except Exception as e:
                    last_err = e
                    continue # Ignore files we can't read

        # Now, try to find the matching window among all gathered windows
        if all_windows:
            j_mock = {"windows": all_windows}
            win = choose_matching_window(j_mock, active_window_title)
            if win:
                tab = extract_selected_tab(win)
                if tab:
                    url, title = tab
                    if URL_RE.match(url or ""):
                        return title or url, url

        # If we're here, no matching window was found yet. Loop and retry.
        last_err = RuntimeError("active window not present in any session file yet")
        time.sleep(0.25)

    raise RuntimeError(f"Could not get active tab ({last_err})")


def normalize_title(t: str):
    if not t:
        return ""
    t = t.strip()
    suffixes = [
        "Zen Browser", "Zen", "Firefox", "LibreWolf", "Waterfox",
        "Chromium", "Google Chrome", "Chrome", "Brave", "Vivaldi",
        "Microsoft Edge", "Edge", "Opera", "Iridium", "Ungoogled-Chromium"
    ]
    # To avoid any potential parsing issues, build the pattern step-by-step
    escaped_suffixes = []
    for s in suffixes:
        escaped_suffixes.append(re.escape(s))

    pattern_interior = "|".join(escaped_suffixes)

    # Using simple string concatenation instead of f-string
    # Using only hyphen to avoid unicode issues
    final_pattern = r"\s+-\s+(" + pattern_interior + r")$"

    t = re.sub(final_pattern, "", t, flags=re.I)
    return t

def choose_matching_window(j: dict, active_title: str):
    active_title_n = normalize_title(active_title)
    wins = j.get("windows", []) or []

    # 1) exact/startswith match on window.title
    for w in wins:
        wt = normalize_title(w.get("title","") or "")
        if wt and (wt == active_title_n or active_title_n.startswith(wt) or wt.startswith(active_title_n)):
            return w

    # 2) match on selected tab's entry title
    for w in wins:
        tab = extract_selected_tab(w, only_title=True)
        if tab:
            _, t = tab
            tn = normalize_title(t)
            if tn and (tn == active_title_n or active_title_n.startswith(tn) or tn.startswith(active_title_n)):
                return w

    # 3) fall back: pick window with highest lastAccessed value.
    if wins:
        wins_sorted = sorted(wins, key=lambda w: w.get("lastAccessed", 0), reverse=True)
        if wins_sorted:
            return wins_sorted[0]
    return None

def extract_selected_tab(window_obj, only_title=False, only_obj=False):
    try:
        tabs = window_obj.get("tabs") or []
        sel = (window_obj.get("selected") or 1) - 1
        if not (0 <= sel < len(tabs)):
            sel = 0
        t = tabs[sel]
        if only_obj:
            return t
        entries = t.get("entries") or []
        idx = (t.get("index") or len(entries)) - 1
        if not (0 <= idx < len(entries)) and entries:
            idx = len(entries) - 1
        if not entries:
            return None
        e = entries[idx]
        url = e.get("url") or ""
        title = e.get("title") or url
        if only_title:
            return url, title
        return url, title
    except Exception:
        return None

# =========================
# Chromium helpers
# =========================

def chromium_profile_dirs():
    home = Path.home()
    roots = [
        home / ".config" / "chromium",
        home / ".config" / "google-chrome",
        home / ".config" / "BraveSoftware" / "Brave-Browser",
        home / ".config" / "vivaldi",
        home / ".config" / "microsoft-edge",
        home / ".config" / "opera",
        home / ".config" / "ungoogled-chromium",
        home / ".config" / "iridium"
    ]
    for r in roots:
        if r.exists():
            yield r

def find_chromium_history():
    for root in chromium_profile_dirs():
        # Default first
        cand = root / "Default" / "History"
        if cand.exists():
            return cand
        # else any Profile */History
        for p in sorted(root.glob("Profile*")):
            if (p / "History").exists():
                return p / "History"
    return None

def chromium_query_latest_by_title(active_title: str):

    hist = find_chromium_history()

    if not hist:

        raise RuntimeError("Chromium history DB not found")



    tmp_dir = None

    conn = None

    try:

        # ALWAYS copy the database to a temporary location to avoid any locks.

        tmp_dir = Path(tempfile.mkdtemp())

        db_path_copy = tmp_dir / "History"



        # Use a robust copy method to ensure the file is copied correctly.

        with open(hist, 'rb') as f_src, open(db_path_copy, 'wb') as f_dst:

            shutil.copyfileobj(f_src, f_dst)



        path = f"file:{db_path_copy}?mode=ro"

        conn = sqlite3.connect(path, uri=True)



        if conn is None:

            # This should not be reached if the copy and connect is successful

            raise RuntimeError("Failed to open copied history DB.")



        cur = conn.cursor()

        norm_title = normalize_title(active_title)

        row = None



        # 1. Exact title match

        cur.execute("""

            SELECT urls.title, urls.url

            FROM urls JOIN visits ON visits.url = urls.id

            WHERE urls.title = ?

            ORDER BY visits.visit_time DESC LIMIT 1

        """, (norm_title,))

        row = cur.fetchone()



        # 2. LIKE title match

        if not row:

            cur.execute("""

                SELECT urls.title, urls.url

                FROM urls JOIN visits ON visits.url = urls.id

                WHERE urls.title LIKE ?

                ORDER BY visits.visit_time DESC LIMIT 1

            """, (f"{norm_title}%",))

            row = cur.fetchone()



        # 3. Final fallback: most recent visit

        if not row:

            cur.execute("""

                SELECT urls.title, urls.url

                FROM urls JOIN visits ON visits.url = urls.id

                ORDER BY visits.visit_time DESC LIMIT 1

            """)

            row = cur.fetchone()



        if row:

            # IMPORTANT: Read values from the row before the connection is closed by the 'finally' block.

            title, url = row[0], row[1]

            if URL_RE.match(url or ""):

                return title or url, url



        raise RuntimeError("Chromium history is empty or unreadable")

    finally:

        try:

            if conn:

                conn.close()

        except Exception:

            pass

        if tmp_dir and tmp_dir.exists():

            shutil.rmtree(tmp_dir, ignore_errors=True)

# =========================
# Actions
# =========================

def action_open():
    ensure_csv()
    # collect items
    items = []
    with open(CSV_PATH, newline="") as f:
        r = csv.reader(f)
        # skip header if present
        header = next(r, None)
        if header and header[:2] == ["title","url"]:
            pass
        else:
            # header is actually first row
            if header:
                items.append(header)
        for row in r:
            if len(row) >= 2:
                items.append(row[:2])

    if not items:
        notify("No bookmarks")
        print("No bookmarks.")
        return 1

    menu_items = [f"{t} - {u}" for t,u in items]

    choice = None
    if shutil.which("wofi"):
        # FIX: wofi --dmenu girdiyi stdin'den bekler; listeyi içeri pipelayalım
        p = subprocess.Popen(["wofi", "--dmenu"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, text=True)
        out, _ = p.communicate("\n".join(menu_items))
        if p.returncode == 0:
            choice = out.strip()
    elif shutil.which("dmenu"):
        p = subprocess.Popen(["dmenu"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, text=True)
        out, _ = p.communicate("\n".join(menu_items))
        if p.returncode == 0:
            choice = out.strip()
    else:
        print("wofi/dmenu not found.")
        return 1

    if not choice:
        return 1

    # parse choice
    try:
        idx = menu_items.index(choice)
    except ValueError:
        # try to split
        if " - " in choice:
            t,u = choice.split(" - ",1)
            url = u.strip()
        else:
            print("Invalid selection.")
            return 1
    else:
        t,u = items[idx]
        url = u

    # launch
    hook = Path.home() / ".local" / "bin" / "launch-browser"
    if hook.exists() and os.access(hook, os.X_OK):
        subprocess.Popen([str(hook), url], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    else:
        subprocess.Popen(["xdg-open", url], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    return 0

def action_edit():
    ensure_csv()
    term = next((t for t in TERMINALS if shutil.which(t)), None)
    if term:
        subprocess.Popen([term, "-e", DEFAULT_EDITOR, str(CSV_PATH)])
    else:
        subprocess.Popen([DEFAULT_EDITOR, str(CSV_PATH)])
    return 0

def action_grab():
    app_cls, win_title = get_active_window()
    fam = is_browser_class(app_cls)
    if fam is None:
        msg = f"Active window is not a supported browser (class={app_cls})"
        notify(msg)
        print(msg)
        return 2

    try:
        if fam == "firefox":
            title, url = read_firefox_active_tab(win_title or "")
        else:
            title, url = chromium_query_latest_by_title(win_title or "")
    except Exception as e:
        msg = f"Failed to get active tab: {e}"
        notify(msg)
        print(msg)
        return 3

    added = csv_append_row(title, url)
    if added:
        notify(f"Saved: {title}")
        print(f"Saved: {title} -> {url}")
    else:
        notify("Already saved")
        print("Already saved")
    return 0

# =========================
# Main
# =========================

def main():
    if len(sys.argv) < 2:
        print("Usage: bookmark {open|edit|grab}")
        return 1
    cmd = sys.argv[1]
    if cmd == "open":
        return action_open()
    if cmd == "edit":
        return action_edit()
    if cmd == "grab":
        return action_grab()
    print("Unknown command.")
    return 1

if __name__ == "__main__":
    sys.exit(main())
