#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sqlite3
import shutil
import xml.etree.ElementTree as ET
import argparse
import sys
import tempfile


def parse_arguments():
    """Parses command-line arguments."""
    parser = argparse.ArgumentParser(
        description="Convert a devhelp book to a Zeal docset.",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    _ = parser.add_argument("devhelp_path", help="Path to the .devhelp2 file")
    _ = parser.add_argument(
        "docset_name",
        nargs="?",
        default=None,
        help="Name of the output docset (e.g., GObject). If not provided, it will be derived from the devhelp file name.",
    )
    _ = parser.add_argument(
        "--path",
        default="~/.local/share/Zeal/Zeal/docsets",
        help="Path to move the generated docset to. Defaults to ~/.local/share/Zeal/Zeal/docsets",
    )

    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)

    args = parser.parse_args()

    if not args.docset_name:
        args.docset_name = os.path.splitext(os.path.basename(args.devhelp_path))[0]
        # Remove .devhelp if it's there
        if args.docset_name.endswith(".devhelp"):
            args.docset_name = os.path.splitext(args.docset_name)[0]
    return args


def create_docset_structure(docset_name):
    """Creates the necessary directory structure for the docset."""
    docset_path = f"{docset_name}.docset"
    contents_path = os.path.join(docset_path, "Contents")
    resources_path = os.path.join(contents_path, "Resources")
    docs_dest = os.path.join(resources_path, "Documents")

    if os.path.exists(docset_path):
        print(f"-> Cleaning existing docset directory: {docset_path}")
        shutil.rmtree(docset_path)

    print(f"-> Creating docset structure for {docset_name}...")
    os.makedirs(docs_dest)
    return docset_path, contents_path, resources_path, docs_dest


def copy_html_files(source_dir, destination_dir):
    """Copies HTML files from the source directory to the docset's Documents directory."""
    print(f"-> Copying HTML files from {source_dir}...")
    shutil.copytree(source_dir, destination_dir, dirs_exist_ok=True)


def find_and_copy_icons(devhelp_path, doc_dir, docset_path):
    """
    Finds and copies icon.png and icon@2x.png for the docset.
    It checks the XML for an 'icon' attribute first, then searches the doc directory.
    """
    icon_copied = False
    retina_icon_copied = False

    def copy_if_found(src_path, dest_filename):
        nonlocal icon_copied, retina_icon_copied
        if os.path.exists(src_path):
            print(f"-> Copying '{src_path}' to '{dest_filename}'")
            shutil.copy(src_path, os.path.join(docset_path, dest_filename))
            if dest_filename == "icon.png":
                icon_copied = True
            elif dest_filename == "icon@2x.png":
                retina_icon_copied = True
            return True
        return False

    # Strategy 1: Look for 'icon' attribute in devhelp XML
    try:
        tree = ET.parse(devhelp_path)
        root = tree.getroot()
        icon_name_from_xml = root.get("icon")
        if icon_name_from_xml:
            icon_path = os.path.join(doc_dir, icon_name_from_xml)
            if copy_if_found(icon_path, "icon.png"):
                # Try to find a retina version based on the XML-specified icon
                base, ext = os.path.splitext(icon_path)
                retina_icon_path = f"{base}@2x{ext}"
                copy_if_found(retina_icon_path, "icon@2x.png")

    except ET.ParseError:
        print(f"-> Warning: Could not parse {devhelp_path}")

    # Strategy 2: Search recursively for 'icon.png' and 'icon@2x.png'
    if not icon_copied or not retina_icon_copied:
        for root, _, files in os.walk(doc_dir):
            if not icon_copied and "icon.png" in files:
                copy_if_found(os.path.join(root, "icon.png"), "icon.png")

            if not retina_icon_copied and "icon@2x.png" in files:
                copy_if_found(os.path.join(root, "icon@2x.png"), "icon@2x.png")

            if icon_copied and retina_icon_copied:
                break  # Found both, no need to search further.

    if not icon_copied and not retina_icon_copied:
        print("-> Warning: No icon found for this docset.")
    elif not icon_copied:
        print("-> Warning: Standard icon 'icon.png' not found.")
    elif not retina_icon_copied:
        print("-> Info: Retina icon 'icon@2x.png' not found.")


def create_info_plist(contents_path, docset_name):
    """Creates the Info.plist file for the docset."""
    info_plist = f"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleIdentifier</key>
    <string>{docset_name}</string>
    <key>CFBundleName</key>
    <string>{docset_name}</string>
    <key>DocSetPlatformFamily</key>
    <string>{docset_name}</string>
    <key>isDashDocset</key>
    <true/>
    <key>dashIndexFilePath</key>
    <string>index.html</string>
</dict>
</plist>"""

    with open(os.path.join(contents_path, "Info.plist"), "w") as f:
        _ = f.write(info_plist)


def create_and_populate_search_index(devhelp_path, resources_path):
    """Creates and populates the SQLite search index."""
    print("-> Indexing API...")
    db_path = os.path.join(resources_path, "docSet.dsidx")
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()
    _ = cur.execute(
        "CREATE TABLE searchIndex(id INTEGER PRIMARY KEY, name TEXT, type TEXT, path TEXT);"
    )
    _ = cur.execute("CREATE UNIQUE INDEX anchor ON searchIndex (name, type, path);")

    tree = ET.parse(devhelp_path)
    root = tree.getroot()
    ns = {"d": "http://www.devhelp.net/book"}

    count = 0
    for function in root.findall(".//d:keyword", namespaces=ns):
        name = function.get("name")
        link = function.get("link")
        type_raw = function.get("type")

        dash_type_map = {
            "struct": "Struct",
            "enum": "Enum",
            "macro": "Macro",
            "property": "Property",
            "signal": "Event",
        }
        dash_type = dash_type_map.get(type_raw, "Function")

        if name and link:
            try:
                cur.execute(
                    "INSERT OR IGNORE INTO searchIndex(name, type, path) VALUES (?, ?, ?)",
                    (name, dash_type, link),
                )
                count += 1
            except Exception:
                pass

    conn.commit()
    conn.close()
    print(f"-> Success! Indexed {count} entries.")


def move_docset_to_destination(docset_path, destination_path):
    """Moves the created docset to the specified destination."""
    dest_path = os.path.expanduser(destination_path)
    if not os.path.exists(dest_path):
        os.makedirs(dest_path)

    final_docset_path = os.path.join(dest_path, os.path.basename(docset_path))
    if os.path.exists(final_docset_path):
        print(f"-> A docset already exists at {final_docset_path}. Replacing it.")
        shutil.rmtree(final_docset_path)

    print(f"-> Moving '{docset_path}' to '{dest_path}'...")
    shutil.move(docset_path, dest_path)
    print(f"-> Docset successfully created and moved to {final_docset_path}")
    print("-> Please restart Zeal to see the new docset.")


def main():
    args = parse_arguments()

    doc_dir = os.path.dirname(args.devhelp_path)

    # Create a temporary directory to build the docset
    temp_build_dir = tempfile.mkdtemp()
    original_cwd = os.getcwd()
    os.chdir(temp_build_dir)

    try:
        docset_path, contents_path, resources_path, docs_dest = create_docset_structure(
            args.docset_name
        )

        copy_html_files(doc_dir, docs_dest)
        find_and_copy_icons(args.devhelp_path, doc_dir, docset_path)
        create_info_plist(contents_path, args.docset_name)
        create_and_populate_search_index(args.devhelp_path, resources_path)
        move_docset_to_destination(docset_path, args.path)
    finally:
        os.chdir(original_cwd)
        shutil.rmtree(temp_build_dir)


if __name__ == "__main__":
    main()
