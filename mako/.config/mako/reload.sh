#!/bin/bash

# This script generates a mako config file by reading the ACTIVE GTK theme.
# It ensures only valid HEX codes are used, falling back to defaults if
# the theme uses complex CSS functions like alpha() or mix().

set -e

CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}"
MAKO_CONFIG="$CONFIG_DIR/mako/config"
SETTINGS_INI="$CONFIG_DIR/gtk-3.0/settings.ini"

# 1. DETECT ACTIVE THEME
if [ ! -f "$SETTINGS_INI" ]; then
    echo "Error: $SETTINGS_INI not found."
    exit 1
fi

THEME_NAME=$(grep 'gtk-theme-name' "$SETTINGS_INI" | awk -F '=' '{print $2}' | tr -d '[:space:]')

if [ -z "$THEME_NAME" ]; then
    echo "Error: Could not detect theme name from $SETTINGS_INI"
    exit 1
fi

echo "Detected GTK Theme: $THEME_NAME"

# 2. LOCATE THEME DIRECTORY
# Check ~/.themes, ~/.local/share/themes, /usr/share/themes
THEME_DIR=""
POSSIBLE_PATHS=(
    "$HOME/.themes/$THEME_NAME"
    "$HOME/.local/share/themes/$THEME_NAME"
    "/usr/share/themes/$THEME_NAME"
)

for path in "${POSSIBLE_PATHS[@]}"; do
    if [ -d "$path" ]; then
        THEME_DIR="$path"
        break
    fi
done

if [ -z "$THEME_DIR" ]; then
    echo "Error: Could not find theme folder for '$THEME_NAME'"
    exit 1
fi

echo "Theme source found at: $THEME_DIR"

# 3. LOCATE COLOR SOURCE FILE
# Priority: gtk-4.0/gtk.css -> gtk-3.0/gtk.css -> gtk-3.0/colors.css
COLOR_SRC=""
CANDIDATES=(
    "$THEME_DIR/gtk-4.0/gtk.css"
    "$THEME_DIR/gtk-3.0/gtk.css"
    "$THEME_DIR/gtk-3.0/colors.css"
    "$THEME_DIR/gtk-3.0/gtk-contained.css"
)

for cand in "${CANDIDATES[@]}"; do
    if [ -f "$cand" ]; then
        if grep -q "@define-color" "$cand"; then
            COLOR_SRC="$cand"
            break
        fi
    fi
done

if [ -z "$COLOR_SRC" ]; then
    echo "Error: Could not find CSS file in $THEME_DIR"
    exit 1
fi

echo "Extracting colors from: $COLOR_SRC"

# 4. RECURSIVE RESOLUTION & VALIDATION
# Returns true (0) if string is a valid hex color (#123456 or #12345678)
is_valid_hex() {
    [[ "$1" =~ ^#[0-9a-fA-F]{6}([0-9a-fA-F]{2})?$ ]]
}

resolve_color() {
    local search_key=$1
    local count=0
    local max_depth=5
    local val=""

    while [ $count -lt $max_depth ]; do
        # Extract the value. strict grep to avoid partial matches
        val=$(grep -E "@define-color[[:space:]]+${search_key}\b" "$COLOR_SRC" | head -n 1 | awk '{print $NF}' | tr -d ';')

        if [ -z "$val" ]; then break; fi

        if [[ "$val" == @* ]]; then
            # Recursive reference
            search_key="${val#@}"
            ((count++))
        elif is_valid_hex "$val"; then
            # Valid Hex found!
            echo "$val"
            return
        else
            # Found something that isn't a reference AND isn't hex (e.g. "alpha(..)" or "black")
            # If it is a simple keyword like "black" or "white", we could map it,
            # but usually it's a complex function. We abort resolution here.
            break
        fi
    done
    echo ""
}

get_color() {
    local name=$1
    local fallback=$2
    local col=$(resolve_color "$name")

    # Final Validation: If resolution failed or returned garbage, use fallback
    if [ -z "$col" ] || ! is_valid_hex "$col"; then
        # Check if fallback is a variable reference (rare, but possible in args)
        if [[ "$fallback" == @* ]]; then
             echo "#000000" # Safety net
        else
             echo "$fallback"
        fi
    else
        echo "$col"
    fi
}

# 5. DEFINE FALLBACKS
# We check if the theme name implies "dark" or "light" to set smart fallbacks
# for colors that fail to resolve (like alpha-blended borders).
if [[ "${THEME_NAME,,}" == *"dark"* ]]; then
    FB_BG="#282828"
    FB_FG="#ebdbb2"
    FB_BORDER="#504945"
else
    # Light theme fallbacks (Gruvbox light style)
    FB_BG="#fbf1c7"
    FB_FG="#3c3836"
    FB_BORDER="#a89984"
fi

# 6. EXTRACT
BG=$(get_color "theme_bg_color" "$FB_BG")
FG=$(get_color "theme_fg_color" "$FB_FG")
BORDER=$(get_color "borders" "$FB_BORDER")
SEL_BG=$(get_color "theme_selected_bg_color" "#458588")

# Critical/Success usually have distinct names, but use generic fallbacks if missing
ERROR=$(get_color "error_color" "#cc241d")
WARNING=$(get_color "warning_color" "#d79921")
SUCCESS=$(get_color "success_color" "#98971a")
LINK=$(get_color "link_color" "#458588")

# 7. GENERATE CONFIG
cat > "$MAKO_CONFIG" <<EOF
# Mako config
# Theme: $THEME_NAME
# Source: $COLOR_SRC
# Generated by reload.sh

font=sans-serif 12
padding=10
border-size=2
border-radius=8
default-timeout=5000
max-visible=5
sort=-time

background-color=${BG}
text-color=${FG}
border-color=${BORDER}
progress-color=${SEL_BG}

[urgency=high]
background-color=${ERROR}
text-color=${FG}
border-color=${BORDER}

[category=success]
background-color=${SUCCESS}
text-color=${FG}
border-color=${BORDER}

[category=warning]
background-color=${WARNING}
text-color=${FG}
border-color=${BORDER}

[category=link]
text-color=${LINK}
EOF

echo "Mako config updated at $MAKO_CONFIG"

# Reload mako
if pgrep -x "mako" > /dev/null; then
    makoctl reload
    echo "Mako reloaded."
fi
